#pragma once
#include <iostream>
using namespace std;

template <typename T>
class List
{
private:

	template <typename T>
	class Node
	{
	public:
		T Data;
		Node* pNext;

		Node(T Data = T(), Node* pNext = nullptr)
		{
			this->Data = Data;
			this->pNext = pNext;
		}
	};
	Node<T>* Head;
	int N_Size;

public:
	//~List(); 
	
	List();
	void Push_back(T Data);
	int Get_Size(){ return N_Size; }
	T& operator[](const int index);
	void Pop_Front();
	void Clear_All();
	~List();
	void Push_front(T Data);
	void Pop_back();
	void InsertAt(T Data,int index);
	void RemoveAt(int index);
};

//template<typename T>
//List<T>::~List()
//{
//	Node<T> *current = this->Head;
//	Node<T>* temp;
//	while (current != nullptr)
//	{
//		temp = current->pNext;
//		delete current[];
//		current = temp;
//	}
//}

template <typename T>
List<T>::List()
{
	N_Size = 0;
	Head = nullptr;
}

template <typename T>
void List<T>::Push_back(T Data)
{
	if (Head == nullptr)
	{
		Head = new Node<T>(Data);
	}
	else
	{
		Node<T>* Current = this->Head; // Current saves the adress of first node,but why we use "this" here?
		while (Current->pNext != nullptr)
		{
			Current = Current->pNext;
		}
		Current->pNext = new Node<T>(Data);
	}
	N_Size++;

}

template <typename T>
T& List<T>::operator[](const int index)
{
	int counter = 0;
	Node<T>* current = this->Head;
	while (current != nullptr)
	{
		if (counter == index)
		{
			return current->Data;
		}
		current = current->pNext;
		counter++;
	}

}

template<typename T>
void List<T>::Pop_Front()
{
	Node<T> temp = this->Head;
	Head = temp->pNext;
	delete temp;
	N_Size--;

}

template<typename T>
void List<T>::Clear_All()
{
	while (Size)
	{
		Pop_Front();
	}
}

template<typename T>
 List<T>::~List()
{
	 Clear_All();
}

 template<typename T>
 void List<T>::InsertAt(T Data,int index)
 {

	 if (index == 0)
	 {
		 Push_front(Data);
	 }
	 else
	 {
		 Node<T>* Previous = this->Head;

         for (int i = 0; i < index - 1; i++)
		 {
			 Previous = Previous -> pNext
		 }
		 Node<T>* newNode = new Node<T>(Data, Previous->pNext);
		 Previous->pNext = newNode;

		 N_Size++;
	 }
 }

 template<typename T>
 void List<T>::RemoveAt(int index)
 {
	 if (index==0)
	 {
		 Pop_Front();
	 }
	 else
	 {
		 Node<T>* Previous = this->Head;
		 for (int i = 0; i < index - 1; i++)
		 {
			 Previous = Previous->pNext;
		 }
		 Node<T>* toDelete = Previous->pNext;
		 Previous - pNext = toDelete->pNext;
		 delete toDelete;
		 N_Size--;
		 
	 }
 }

 template<typename T>
 void List<T>::Push_front(T Data)
 {
	 Head = new Node<T>(Data, Head);
	 N_Size++;

 }

 template<typename T>
 void List<T>::Pop_back()
 {
	 RemoveAt(this->N_Size - 1);
 }







